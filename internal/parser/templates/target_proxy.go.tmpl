// Code generated by gen-go-proxy. DO NOT EDIT.
// source: {{.SourceFile}}

package {{.PackageName}}

import (
    {{range .Imports -}}
    {{.Alias}} "{{.Path}}"
    {{end}}
)

{{range .Interfaces}}

const(
    {{ $InterfaceName := .InterfaceName }}
    {{range .AllAnnotations -}}
        {{.AnnotationName}}AnnotationKeyOn{{$InterfaceName}} string = "{{.AnnotationName}}"
    {{end}}
)

// helper for {{.ProxyTypeName}} middleware
type {{.ProxyTypeName}}Middleware func(func(context.Context) error) func(context.Context) error
type {{.ProxyTypeName}}Middlewares []{{.ProxyTypeName}}Middleware 

// convert {{.ProxyTypeName}} middleware to raw type
func (a {{.ProxyTypeName}}Middlewares) To() []func(func(context.Context) error) func(context.Context) error {
	m := []func(func(context.Context) error) func(context.Context) error{}
	for _, v := range a {
		m = append(m, v)
	}
	return m
}

// helper for {{.ProxyTypeName}} middleware map about middlewares by aannotation 
type {{.ProxyTypeName}}MiddlewareByAnnotation map[string]{{.ProxyTypeName}}Middlewares

// convert {{.ProxyTypeName}} middleware map to raw type
func (a {{.ProxyTypeName}}MiddlewareByAnnotation) To() map[string][]func(func(context.Context) error) func(context.Context) error {
	m := map[string][]func(func(context.Context) error) func(context.Context) error{}
	for key, value := range a {
		m[key] = value.To()
	}
	return m
}

// implement proxy for {{.InterfaceName}}
type {{.ProxyTypeName}} struct {
    target {{if .IsDiffrentPackage}}{{.InterfacePackage}}.{{end}}{{.InterfaceName}}
    {{range .AllAnnotations -}}
        {{.AnnotationName}}Middlewares []func(func(context.Context) error) func(context.Context) error
    {{end -}}
}

func New{{.ProxyTypeName}}(target {{if .IsDiffrentPackage}}{{.InterfacePackage}}.{{end}}{{.InterfaceName}}, middlewares map[string][]func(func(context.Context) error) func(context.Context) error) *{{.ProxyTypeName}} {
    p := &{{.ProxyTypeName}}{
        target: target,
    }

    for key, value := range middlewares {
        switch key {
        {{ $InterfaceName := .InterfaceName }}
        {{range .AllAnnotations -}}
            case {{.AnnotationName}}AnnotationKeyOn{{$InterfaceName}}:
                p.{{.AnnotationName}}Middlewares = value
        {{end -}}
        }
    }

    return p
}

{{range .Methods}}
func (p *{{.ProxyTypeName}}) {{.Name}}({{.Params}}) {{.ResultTypes}} {
    {{if .UseProxy -}}
        {{if .HasResults -}}
            var (
            {{range .Results}}
                {{.ResultVar}} {{.ResultType -}}
            {{end}}
            )
        {{end}}

        f := func({{.HelperContextParam}} context.Context) error {
        {{if .HasResults -}}
            {{.ResultVars}} = p.target.{{.Name}}( {{if .HasContext}} {{.ParamNamesWithHelperContext}} {{else}} {{.ParamNames}} {{end -}} )
            {{if .HasError -}}
                if err != nil {
                    return err
                }
            {{end -}}
        {{else -}}
            p.target.{{.Name}}({{.ParamNames}})
        {{end -}}
            return nil
        }

        {{ $methodName := .Name }}
        {{range $i, $v := .Annotations -}}
            {{if eq $v.MethodName $methodName -}}
                for i := range p.{{$v.AnnotationName}}Middlewares {
                    index := len(p.{{$v.AnnotationName}}Middlewares) - i - 1
                    f = p.{{$v.AnnotationName}}Middlewares[index](f)
                }
            {{end}}
        {{end}}

        f( {{if .HasContext}} {{.UserContextParam}} {{else}} context.TODO() {{end -}})
        {{if .HasResults -}}
            return {{.ResultVars}}
        {{end -}}
    {{else -}}
        {{if .HasResults}} return {{end}} p.target.{{.Name}}({{.ParamNames}})
    {{end -}}
}
{{end}}
{{end}}